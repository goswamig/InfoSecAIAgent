import requests
import schedule
import time
from datetime import datetime, timedelta
from coordinater import CoordinatorAgent

class VulnerabilityScannerAgent:
    def __init__(self):
        self.cve_database = {}
        self.system_inventory = {}
        self.last_update = None
        self.update_interval = timedelta(hours=24)

    def update_cve_database(self):
        # In a real-world scenario, you would use an API to fetch CVE data
        # For this example, we'll simulate fetching from a URL
        url = "https://cve.mitre.org/data/downloads/allitems.csv"
        try:
            response = requests.get(url)
            if response.status_code == 200:
                # Process the CSV data and update self.cve_database
                # This is a simplified example
                self.cve_database = self.parse_cve_data(response.text)
                self.last_update = datetime.now()
                print(f"CVE database updated at {self.last_update}")
            else:
                print(f"Failed to fetch CVE data. Status code: {response.status_code}")
        except Exception as e:
            print(f"Error updating CVE database: {str(e)}")

    def parse_cve_data(self, csv_data):
        # This is a simplified parser. In reality, you'd need a more robust CSV parser
        cve_dict = {}
        for line in csv_data.split('\n')[1:]:  # Skip header
            parts = line.split(',')
            if len(parts) >= 3:
                cve_id = parts[0]
                description = parts[2]
                cve_dict[cve_id] = description
        return cve_dict

    def update_system_inventory(self, target):
        # In a real scenario, you would scan the target system to get this information
        # For this example, we'll use a mock inventory
        self.system_inventory = {
            "Apache": "2.4.41",
            "MySQL": "5.7.32",
            "PHP": "7.4.12",
            "OpenSSL": "1.1.1g"
        }
        print(f"System inventory updated for {target}")

    def check_vulnerabilities(self):
        vulnerabilities = []
        for software, version in self.system_inventory.items():
            for cve_id, description in self.cve_database.items():
                if software.lower() in description.lower() and version in description:
                    vulnerabilities.append(f"{cve_id}: {description}")
        return vulnerabilities

    def run(self, target):
        if not self.last_update or datetime.now() - self.last_update > self.update_interval:
            self.update_cve_database()
        
        self.update_system_inventory(target)
        vulnerabilities = self.check_vulnerabilities()
        
        if vulnerabilities:
            return f"Vulnerabilities found on {target}:\n" + "\n".join(vulnerabilities)
        else:
            return f"No known vulnerabilities found on {target}"

    def start_continuous_monitoring(self, target, interval_minutes=60):
        schedule.every(interval_minutes).minutes.do(self.continuous_scan, target)
        
        while True:
            schedule.run_pending()
            time.sleep(1)

    def continuous_scan(self, target):
        print(f"Running continuous scan on {target} at {datetime.now()}")
        result = self.run(target)
        print(result)

# Usage
scanner = VulnerabilityScannerAgent()
coordinator = CoordinatorAgent()
coordinator.add_agent(scanner)

# Run a single scan
result = coordinator.run_security_assessment("example.com")
print(result[0])  # Print the result from the VulnerabilityScannerAgent

# Start continuous monitoring
scanner.start_continuous_monitoring("example.com", interval_minutes=1)